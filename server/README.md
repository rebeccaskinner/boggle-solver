# Boggle Solver

This application provides a basic backend server to run a boggle game.  It's
written in haskell and uses stack for the build system.  You can install stack
based on [the online documentation](https://www.haskellstack.org), or get
started quickly by running:

```
curl -sSL https://get.haskellstack.org/ | sh
```

## Building

To build the application, use: `stack build`

## Running

To run the application with stack, use:

```
stack exec boggle-solver -- dictionary_path ui_path
```

For the dictionary, you can provide any file containing newline-separated utf8
words that you want.  I have tested the application on macOS Mojave with
`/usr/share/dict/words` as the input dictionary.  The UI file should be the one
generated by the frontend.  See the readme in the `frontend` directory for more
information on building the frontend.

## Manual Testing

The `sample_req` file contains a basic http request that demonstrates the format
of the API.

# Design Notes

This application is broken up into three modules, `App`, `Server` and `Boggle`,
which are briefly described below:

## App

App provides a basic monad transformer stack for running the application, along
with a configuration record for handling command line arguments.

## Server

This module uses a basic stack servant API server template to serve the Boggle
API.

## Boggle

This module provides the boggle solver.  The algorithm that is used is a fairly
simple graph traversal approach.  A dictionary of known words are loaded into a
patricia tree, and a graph representing the path from a given starting letter
through the entire board is generated for each starting point.  We traverse each
graph and look up an associated item in the dictionary tree.  If at any point
there are no entries in the dictionary, we stop searching.

# Future Work

There were a number of shortcuts that were taken to ensure that this project
could be completed within the 4-hour time limit.  Most significantly, no tests
have been written.  In a production application, I would include unit tests to
ensure that the application worked as expected.  Additionally, I have not
profiled the application, nor done any significant optimizations beyond choosing
an effective algorithm. Below, I've described a few particular changes that
could be made to improve the application:

## Feature Improvements

### Unicode Support

This application does not have full support for unicode code points, by virtue
of it's use of Word8/Char8 data types to store individual letters.  Adding
unicode support would be straightforward, but would require a little bit of
additional effort due to the fact that we could not naively use the
bytestring-trie library.

### Custom Dictionary Support

This application does not provide a configurable dictionary per-game.  We could
allow users to either upload a custom dictionary, or else allow the person
running the application to specify an arbitrary number of dictionaries that
could be referred to by name.

## Performance

The algorithm that we're using here is reasonably efficient, but there are a
number of things that could be done to make it more efficient.  In particular,
using more efficient data structures, memoization of subgraph lookups,
reducing the memory footprint by forcing strictness to reduce thunk
accumulation, and doing actual profiling.
